import numpy as np
import os

def get_dataset(data_dir, m_file_path, seed=None):
    """
    Loads preprocessed feature files generated by preprocess.py.
    
    The data_dir parameter should point to the directory containing the three 
    large .npy files.
    The m_file_path parameter is not used in this function but is kept for 
    compatibility with the main training script signature.
    """

    # 1. Load your training features (must be all "normal" samples)
    train_path = os.path.join(data_dir, "my_train_features.npy")
    try:
        data_train_id = np.load(train_path)
    except FileNotFoundError:
        print(f"FATAL ERROR: Training feature file not found at {train_path}")
        print("Please ensure you have run the preprocess.py script,")
        print(f"and that the 'data_dir' path in main.py is set correctly (currently: {data_dir}).")
        exit()
    
    # 2. Training labels are all 0 (normal/ID)
    labels_train_id = np.zeros(data_train_id.shape[0])

    # 3. Load your testing features
    test_path = os.path.join(data_dir, "my_test_features.npy")
    try:
        data_test = np.load(test_path)
    except FileNotFoundError:
        print(f"FATAL ERROR: Test feature file not found at {test_path}")
        print("Please ensure you have run the preprocess.py script.")
        exit()
    
    # 4. Load your testing labels
    labels_path = os.path.join(data_dir, "my_test_labels.npy")
    try:
        labels_test = np.load(labels_path)
    except FileNotFoundError:
        print(f"FATAL ERROR: Test label file not found at {labels_path}")
        print("Please ensure you have run the preprocess.py script.")
        exit()

    # ID to Type Mapping (0: Normal, 1: Anomaly)
    id_to_type = {
        0: "normal",
        1: "anomaly"
    }

    print(f"Data Loaded Successfully: Train Set {data_train_id.shape}, Test Features {data_test.shape}, Test Labels {labels_test.shape}")
    
    # 5. Return the four arrays and the mapping
    return data_train_id, labels_train_id, data_test, labels_test, id_to_type

def create_meshgrid_from_data(data, n_points=100, meshgrid_offset=1):
    """
    Generates a 2D meshgrid for visualization purposes.
    
    This function will only be triggered by the train_and_evaluate logic 
    if the feature dimension is 2D. It is kept here to prevent import errors 
    in the main script.
    
    :param data: The input data array (assumed to be 2D).
    :param n_points: Number of points along each dimension of the grid.
    :param meshgrid_offset: Padding added to the min/max of the data range.
    :return: xx and yy meshgrid arrays.
    """
    if data.ndim < 2 or data.shape[1] != 2:
        # Check if data is not 2D, return placeholders
        print("Data is not 2D. Skipping meshgrid creation.")
        return np.array([]), np.array([])
        
    print("Creating meshgrid (for 2D visualization only)...")
    try:
        x_min, x_max = data[:, 0].min() - meshgrid_offset, data[:, 0].max() + meshgrid_offset
        y_min, y_max = data[:, 1].min() - meshgrid_offset, data[:, 1].max() + meshgrid_offset
        xx, yy = np.meshgrid(np.linspace(x_min, x_max, n_points), np.linspace(y_min, y_max, n_points))
        return xx, yy
    except IndexError:
        print("An error occurred during meshgrid creation. Returning empty arrays.")
        # Return empty arrays in case of unexpected errors
        return np.array([]), np.array([])